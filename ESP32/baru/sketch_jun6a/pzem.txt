#define BLYNK_TEMPLATE_ID "TMPL6ywUDi0KH"
#define BLYNK_TEMPLATE_NAME "SKRIPSI"
#define BLYNK_AUTH_TOKEN "pHhfrcARqOh-kuInrA03bm2I5csO5qzD"

#include <WiFi.h>
#include <BlynkSimpleEsp32.h>
#include <PZEM004Tv30.h>
#include <Wire.h>
#include <RTClib.h>
#include <LiquidCrystal_I2C.h>

char ssid[] = "RUMAHCEMARA";
char pass[] = "Sandi1sampai10";

PZEM004Tv30 pzem(&Serial2, 16, 17);
RTC_DS3231 rtc;
LiquidCrystal_I2C lcd1(0x27, 20, 4); // LCD 20x4
LiquidCrystal_I2C lcd2(0x26, 16, 2); // LCD 16x2

const int pumpPin = 25;
const int pirPin = 26;

bool isAutoMode = true;
bool manualPump = false;
bool pumpActive = false;

bool simulatePZEM = true; // Aktifkan simulasi

unsigned long pumpStartTime = 0;
const unsigned long pumpDuration = 5000;
const unsigned long scheduleInterval = 30UL * 60UL * 1000UL;
unsigned long lastScheduledPumpTime = 0;

char nextPumpTimeStr[25] = "";

BlynkTimer timer;

void setup() {
  Serial.begin(115200);
  Serial2.begin(9600, SERIAL_8N1, 16, 17);
  Wire.begin(21, 22);

  lcd1.init(); lcd1.backlight(); lcd1.clear();
  lcd1.setCursor(0, 0); lcd1.print("Inisialisasi..");

  lcd2.init(); lcd2.backlight(); lcd2.clear();
  lcd2.setCursor(0, 0); lcd2.print("Inisialisasi..");

  pinMode(pumpPin, OUTPUT);
  pinMode(pirPin, INPUT);
  digitalWrite(pumpPin, LOW);

  if (!rtc.begin()) {
    lcd1.setCursor(0, 1); lcd1.print("RTC ERROR!");
    lcd2.setCursor(0, 1); lcd2.print("RTC ERROR!");
    while (1);
  }

  Blynk.begin(BLYNK_AUTH_TOKEN, ssid, pass);

  timer.setInterval(1000L, updateDisplay);
  timer.setInterval(2000L, sendToBlynk);
  timer.setInterval(5000L, updateNextPumpTimeDisplay);
}

bool isNightTime(DateTime now) {
  int hour = now.hour();
  return (hour >= 18 || hour < 5);
}

void loop() {
  Blynk.run();
  timer.run();

  DateTime now = rtc.now();
  unsigned long nowMillis = millis();

  if (isAutoMode && !pumpActive && isNightTime(now)) {
    if (nowMillis - lastScheduledPumpTime >= scheduleInterval) {
      activatePump(nowMillis);
    }
  }

  if (pumpActive && nowMillis - pumpStartTime >= pumpDuration) {
    deactivatePump();
  }

  if (!isAutoMode && !pumpActive) {
    digitalWrite(pumpPin, manualPump ? HIGH : LOW);
    updatePumpStatusToBlynk(manualPump);
  }
}

void activatePump(unsigned long nowMillis) {
  digitalWrite(pumpPin, HIGH);
  pumpStartTime = nowMillis;
  pumpActive = true;
  lastScheduledPumpTime = nowMillis;
  updatePumpStatusToBlynk(true);
}

void deactivatePump() {
  digitalWrite(pumpPin, LOW);
  pumpActive = false;
  updatePumpStatusToBlynk(false);
}

void updateDisplay() {
  DateTime now = rtc.now();

  float voltage, current, power, energy;

  if (simulatePZEM) {
    voltage = random(210, 231);
    current = random(10, 51) / 10.0;
    power   = voltage * current;
    energy  = power * 0.001;
  } else {
    voltage = pzem.voltage();
    current = pzem.current();
    power   = pzem.power();
    energy  = pzem.energy();

    if (isnan(voltage)) voltage = 0.00;
    if (isnan(current)) current = 0.00;
    if (isnan(power))   power = 0.00;
    if (isnan(energy))  energy = 0.00;
  }

  bool pirStatus = digitalRead(pirPin);

  lcd1.setCursor(0, 0);
  lcd1.printf("%02d/%02d/%02d %02d:%02d:%02d   ",
              now.day(), now.month(), now.year() % 100,
              now.hour(), now.minute(), now.second());

  lcd1.setCursor(0, 1);
  if (isNightTime(now)) {
    lcd1.printf("Next: %-16s", nextPumpTimeStr);
  } else {
    lcd1.print("SIANG - OFF         ");
  }

  lcd1.setCursor(0, 2);
  lcd1.printf("PIR: %-15s", pirStatus ? "TERDETEKSI" :"TIDAKTERDETEKSI");

  lcd1.setCursor(0, 3);
  const char* pompaStr = pumpActive ? "AKTIF" : (manualPump ? "MANUAL ON" : "OFF");
  lcd1.printf("POMPA: %-10s", pompaStr);

  lcd2.setCursor(0, 0);
  char line1[17];
  snprintf(line1, sizeof(line1), "V:%.1fV I:%.1fA", voltage, current);
  lcd2.print(line1);

  lcd2.setCursor(0, 1);
  char line2[17];
  snprintf(line2, sizeof(line2), "P:%.1fW E:%.1fWh", power, energy);
  lcd2.print(line2);
}

void sendToBlynk() {
  DateTime now = rtc.now();

  float voltage, current, power, energy;

  if (simulatePZEM) {
    voltage = random(210, 231);
    current = random(10, 51) / 10.0;
    power   = voltage * current;
    energy  = power * 0.001;
  } else {
    voltage = pzem.voltage();
    current = pzem.current();
    power   = pzem.power();
    energy  = pzem.energy();

    if (isnan(voltage)) voltage = 0.00;
    if (isnan(current)) current = 0.00;
    if (isnan(power))   power = 0.00;
    if (isnan(energy))  energy = 0.00;
  }

  Blynk.virtualWrite(V2, String(voltage, 3) + " V");
  Blynk.virtualWrite(V3, String(current, 3) + " A");
  Blynk.virtualWrite(V4, String(power, 3) + " W");
  Blynk.virtualWrite(V5, String(energy, 3) + " Wh");

  char timeString[25];
  sprintf(timeString, "%02d/%02d/%04d %02d:%02d:%02d",
          now.day(), now.month(), now.year(),
          now.hour(), now.minute(), now.second());
  Blynk.virtualWrite(V6, timeString);

  bool pirStatus = digitalRead(pirPin);
  Blynk.virtualWrite(V9, pirStatus ? "TERDETEKSI" : "TIDAKTERDETEKSI");

  if (!isNightTime(now)) {
    Blynk.virtualWrite(V8, "SIANG - OFF");
  }
}

void updatePumpStatusToBlynk(bool isOn) {
  Blynk.virtualWrite(V7, isOn ? "ON" : "OFF");
}

void updateNextPumpTimeDisplay() {
  DateTime now = rtc.now();
  unsigned long timeLeft = scheduleInterval - (millis() - lastScheduledPumpTime);
  if (timeLeft > scheduleInterval) timeLeft = 0;
  DateTime nextPump = now + TimeSpan(timeLeft / 1000);

  if (isNightTime(now)) {
    sprintf(nextPumpTimeStr, "%02d/%02d %02d:%02d:%02d",
            nextPump.day(), nextPump.month(),
            nextPump.hour(), nextPump.minute(), nextPump.second());
    Blynk.virtualWrite(V8, nextPumpTimeStr);
  } else {
    strcpy(nextPumpTimeStr, "SIANG - OFF");
    Blynk.virtualWrite(V8, "SIANG - OFF");
  }
}

// === Kontrol dari Blynk ===
BLYNK_WRITE(V0) {
  isAutoMode = param.asInt() == 1;
}

BLYNK_WRITE(V1) {
  manualPump = param.asInt();
}